import { jest } from '@jest/globals';
import { PortfolioGridBot } from '../../src/bot/portfolioBot.js';
import { BinanceClient } from '../../src/exchange/binance.js';
import type { PairConfig } from '../../src/types/portfolio.js';

// Mock dependencies
jest.mock('../../src/exchange/binance.js');
jest.mock('../../src/exchange/binanceStreams.js');
jest.mock('../../src/bot/portfolioRisk.js');
jest.mock('../../src/analysis/correlation.js', () => ({
  correlationAnalyzer: {
    updatePriceHistory: jest.fn(),
    getCorrelation: jest.fn(),
  },
}));
jest.mock('../../src/models/database.js', () => ({
  tradingDb: {
    savePortfolioSnapshot: jest.fn(),
    saveGridState: jest.fn(),
  },
}));
jest.mock('../../src/utils/logger.js', () => ({
  createLogger: () => ({
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
  }),
}));
jest.mock('../../src/utils/config.js', () => ({
  config: {
    simulationMode: true,
  },
}));

describe('PortfolioGridBot', () => {
  let bot: PortfolioGridBot;
  let mockClient: jest.Mocked<BinanceClient>;

  const mockPairConfigs: PairConfig[] = [
    {
      symbol: 'DOGEUSDT',
      baseAsset: 'DOGE',
      quoteAsset: 'USDT',
      gridUpper: 0.18,
      gridLower: 0.10,
      gridCount: 7,
      amountPerGrid: 100,
      gridType: 'arithmetic',
      allocationPercent: 50,
      enabled: true,
    },
    {
      symbol: 'XLMUSDT',
      baseAsset: 'XLM',
      quoteAsset: 'USDT',
      gridUpper: 0.32,
      gridLower: 0.17,
      gridCount: 7,
      amountPerGrid: 50,
      gridType: 'arithmetic',
      allocationPercent: 50,
      enabled: true,
    },
  ];

  beforeEach(() => {
    mockClient = new BinanceClient() as jest.Mocked<BinanceClient>;

    // Setup mock implementations
    mockClient.connect = jest.fn() as any;
    mockClient.disconnect = jest.fn() as any;
    mockClient.getBalance = jest.fn() as any;

    bot = new PortfolioGridBot(mockClient, {
      pairs: [],
      totalCapital: 2000,
      riskStrategy: 'moderate',
      rebalanceThreshold: 10,
      rebalanceInterval: 60000,
      priceHistoryDays: 30,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Constructor', () => {
    it('should initialize with correct parameters', () => {
      expect(bot).toBeInstanceOf(PortfolioGridBot);
      const status = bot.getStatus();
      expect(status.status).toBe('stopped');
      expect(status.riskStatus.strategy).toBe('moderate');
    });

    it('should accept different risk strategies', () => {
      const conservativeBot = new PortfolioGridBot(mockClient, {
        pairs: [],
        totalCapital: 2000,
        riskStrategy: 'conservative',
        rebalanceThreshold: 10,
        rebalanceInterval: 60000,
        priceHistoryDays: 30,
      });
      const aggressiveBot = new PortfolioGridBot(mockClient, {
        pairs: [],
        totalCapital: 2000,
        riskStrategy: 'aggressive',
        rebalanceThreshold: 10,
        rebalanceInterval: 60000,
        priceHistoryDays: 30,
      });

      const conservativeStatus = conservativeBot.getStatus();
      const aggressiveStatus = aggressiveBot.getStatus();
      expect(conservativeStatus.riskStatus.strategy).toBe('conservative');
      expect(aggressiveStatus.riskStatus.strategy).toBe('aggressive');
    });
  });

  describe('addPair()', () => {
    it('should add a pair successfully', async () => {
      const result = await bot.addPair(mockPairConfigs[0]);

      expect(result).toBe(true);
      const pairs = bot.getAllPairs();
      expect(pairs).toContain('DOGEUSDT');
    });

    it('should not add duplicate pair', async () => {
      await bot.addPair(mockPairConfigs[0]);
      const result = await bot.addPair(mockPairConfigs[0]);

      expect(result).toBe(false);
      const pairs = bot.getAllPairs();
      expect(pairs.length).toBe(1);
    });

    it('should handle multiple pairs', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.addPair(mockPairConfigs[1]);

      const pairs = bot.getAllPairs();
      expect(pairs).toContain('DOGEUSDT');
      expect(pairs).toContain('XLMUSDT');
      expect(pairs.length).toBe(2);
    });
  });

  describe('removePair()', () => {
    it('should remove a pair successfully', async () => {
      await bot.addPair(mockPairConfigs[0]);
      const result = await bot.removePair('DOGEUSDT');

      expect(result).toBe(true);
      const pairs = bot.getAllPairs();
      expect(pairs).not.toContain('DOGEUSDT');
    });

    it('should return false for non-existent pair', async () => {
      const result = await bot.removePair('BTCUSDT');

      expect(result).toBe(false);
    });

    it('should not remove pair while bot is running', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.start();

      const result = await bot.removePair('DOGEUSDT');

      expect(result).toBe(false);
      const pairs = bot.getAllPairs();
      expect(pairs).toContain('DOGEUSDT');

      await bot.stop();
    });
  });

  describe('start() and stop()', () => {
    it('should start the portfolio bot', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.start();

      const status = bot.getStatus();
      expect(status.status).toBe('running');
      expect(mockClient.connect).toHaveBeenCalled();

      await bot.stop();
    });

    it('should not start without pairs', async () => {
      await bot.start();

      const status = bot.getStatus();
      expect(status.status).toBe('stopped');
    });

    it('should stop the portfolio bot', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.start();
      await bot.stop();

      const status = bot.getStatus();
      expect(status.status).toBe('stopped');
      expect(mockClient.disconnect).toHaveBeenCalled();
    });
  });

  describe('getStatus()', () => {
    it('should return portfolio status', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.addPair(mockPairConfigs[1]);

      const status = bot.getStatus();

      expect(status).toHaveProperty('status');
      expect(status).toHaveProperty('pairs');
      expect(status).toHaveProperty('totalPnl');
      expect(status).toHaveProperty('riskStatus');
      expect(status.pairs.length).toBe(2);
    });

    it('should calculate portfolio metrics correctly', async () => {
      await bot.addPair(mockPairConfigs[0]);

      const status = bot.getStatus();

      expect(status.totalPnl).toBeGreaterThanOrEqual(0);
      expect(status.totalTrades).toBeGreaterThanOrEqual(0);
    });
  });

  describe('getPairDetails()', () => {
    it('should return pair details for existing pair', async () => {
      await bot.addPair(mockPairConfigs[0]);

      const details = bot.getPairDetails('DOGEUSDT');

      expect(details).not.toBeNull();
      expect(details).toHaveProperty('config');
      expect(details).toHaveProperty('status');
    });

    it('should return null for non-existent pair', () => {
      const details = bot.getPairDetails('BTCUSDT');

      expect(details).toBeNull();
    });
  });

  describe('updateRiskStrategy()', () => {
    it('should update risk strategy', () => {
      bot.updateRiskStrategy('aggressive');

      const status = bot.getStatus();
      expect(status.riskStatus.strategy).toBe('aggressive');
    });

    it('should update to conservative', () => {
      bot.updateRiskStrategy('conservative');

      const status = bot.getStatus();
      expect(status.riskStatus.strategy).toBe('conservative');
    });
  });

  describe('Portfolio Allocation', () => {
    it('should track multiple pairs', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.addPair(mockPairConfigs[1]);

      const status = bot.getStatus();
      expect(status.pairs.length).toBe(2);
    });

    it('should respect max exposure limits based on strategy', async () => {
      await bot.addPair(mockPairConfigs[0]);

      const limits = bot.getRiskLimits();

      // Moderate strategy: 75% max exposure
      expect(limits.maxTotalExposure).toBe(75);
    });
  });

  describe('getAllPairs()', () => {
    it('should return empty array when no pairs', () => {
      const pairs = bot.getAllPairs();

      expect(Array.isArray(pairs)).toBe(true);
      expect(pairs.length).toBe(0);
    });

    it('should return all added pairs', async () => {
      await bot.addPair(mockPairConfigs[0]);
      await bot.addPair(mockPairConfigs[1]);

      const pairs = bot.getAllPairs();

      expect(pairs.length).toBe(2);
      expect(pairs).toEqual(expect.arrayContaining(['DOGEUSDT', 'XLMUSDT']));
    });
  });

  describe('getRiskLimits()', () => {
    it('should return risk limits for current strategy', () => {
      const limits = bot.getRiskLimits();

      expect(limits).toHaveProperty('maxTotalExposure');
      expect(limits).toHaveProperty('maxDailyLoss');
      expect(limits).toHaveProperty('maxDrawdown');
      expect(limits).toHaveProperty('consecutiveLossLimit');
    });

    it('should have different limits for different strategies', () => {
      const conservativeBot = new PortfolioGridBot(mockClient, {
        pairs: [],
        totalCapital: 2000,
        riskStrategy: 'conservative',
        rebalanceThreshold: 10,
        rebalanceInterval: 60000,
        priceHistoryDays: 30,
      });
      const moderateBot = new PortfolioGridBot(mockClient, {
        pairs: [],
        totalCapital: 2000,
        riskStrategy: 'moderate',
        rebalanceThreshold: 10,
        rebalanceInterval: 60000,
        priceHistoryDays: 30,
      });
      const aggressiveBot = new PortfolioGridBot(mockClient, {
        pairs: [],
        totalCapital: 2000,
        riskStrategy: 'aggressive',
        rebalanceThreshold: 10,
        rebalanceInterval: 60000,
        priceHistoryDays: 30,
      });

      const conservativeLimits = conservativeBot.getRiskLimits();
      const moderateLimits = moderateBot.getRiskLimits();
      const aggressiveLimits = aggressiveBot.getRiskLimits();

      expect(conservativeLimits.maxTotalExposure).toBeLessThan(moderateLimits.maxTotalExposure);
      expect(moderateLimits.maxTotalExposure).toBeLessThan(aggressiveLimits.maxTotalExposure);
    });
  });
});

name: Deploy to AWS

on:
  push:
    branches:
      - main  # Deploy only from main branch
  workflow_dispatch:  # Allow manual trigger

concurrency:
  group: deploy-production
  cancel-in-progress: true  # Automatically cancel previous runs

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: crypto-trading-bot-prod
  TERRAFORM_VERSION: 1.6.0

jobs:
  test:
    name: Run Tests Before Deploy
    uses: ./.github/workflows/test.yml

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    env:
      AWS_REGION: us-east-1
      AWS_DEFAULT_REGION: us-east-1
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set AWS credentials as env vars
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_REGION=us-east-1" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=us-east-1" >> $GITHUB_ENV

      - name: Check and fix AWS config
        run: |
          echo "=== AWS Config Before ==="
          cat ~/.aws/config || echo "No config file"
          echo "========================"

          # Remove any config that might have wrong region
          rm -rf ~/.aws/config
          mkdir -p ~/.aws

          # Create fresh config with us-east-1 only
          cat > ~/.aws/config <<EOF
          [default]
          region = us-east-1
          output = json
          EOF

          echo "=== AWS Config After ==="
          cat ~/.aws/config
          echo "========================"

      - name: Login to Amazon ECR (manual)
        id: login-ecr
        run: |
          # Get account ID and construct registry URL
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"

          echo "Logging into ECR registry: $REGISTRY"

          # Get ECR login password and login to Docker
          aws ecr get-login-password --region us-east-1 | \
            docker login --username AWS --password-stdin $REGISTRY

          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "Successfully logged into ECR in us-east-1"

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-scanning-configuration scanOnPush=true \
            --region ${{ env.AWS_REGION }} \
            --tags Key=Project,Value=crypto-trading-bot Key=Environment,Value=prod

      - name: Get AWS Account ID and construct tags
        id: aws-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"
          REPO="${REGISTRY}/crypto-trading-bot-prod"
          TAG1="${REPO}:${GITHUB_SHA}"
          TAG2="${REPO}:latest"

          echo "=== Docker Registry Configuration ==="
          echo "Account ID: ${ACCOUNT_ID}"
          echo "Registry: ${REGISTRY}"
          echo "Repository: ${REPO}"
          echo "Tag 1: ${TAG1}"
          echo "Tag 2: ${TAG2}"
          echo "======================================"

          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repo=${REPO}" >> $GITHUB_OUTPUT
          echo "tag1=${TAG1}" >> $GITHUB_OUTPUT
          echo "tag2=${TAG2}" >> $GITHUB_OUTPUT

      - name: Login to ECR (us-east-1 only)
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"

          echo "Logging into ECR registry: $REGISTRY"
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $REGISTRY

      - name: Build Docker image locally (no tags yet)
        env:
          DOCKER_BUILDKIT: 0
        run: |
          echo "Building Docker image WITHOUT tags to avoid auto-push"
          docker build --build-arg NODE_ENV=production -t temp-build .

      - name: Tag and push to ECR using AWS CLI
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"
          REPO="crypto-trading-bot-prod"

          echo "Tagging image..."
          docker tag temp-build "${REGISTRY}/${REPO}:${GITHUB_SHA}"
          docker tag temp-build "${REGISTRY}/${REPO}:latest"

          echo "Images after tagging:"
          docker images | grep -E "(temp-build|crypto-trading-bot)"

          echo "Pushing to ${REGISTRY}/${REPO}:${GITHUB_SHA}"
          docker push "${REGISTRY}/${REPO}:${GITHUB_SHA}"

          echo "Pushing to ${REGISTRY}/${REPO}:latest"
          docker push "${REGISTRY}/${REPO}:latest"

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Create terraform.tfvars from secrets
        working-directory: terraform
        run: |
          cat > terraform.tfvars <<EOF
          project_name        = "crypto-trading-bot"
          environment         = "prod"
          aws_region          = "${{ env.AWS_REGION }}"
          instance_type       = "t3.small"
          allowed_ips         = ${{ secrets.ALLOWED_IPS }}
          cognito_user_email  = "${{ secrets.COGNITO_USER_EMAIL }}"
          binance_api_key     = "${{ secrets.BINANCE_API_KEY }}"
          binance_api_secret  = "${{ secrets.BINANCE_API_SECRET }}"
          ssh_key_name        = "${{ secrets.SSH_KEY_NAME }}"
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Format
        working-directory: terraform
        run: terraform fmt

      - name: Terraform Format Check
        working-directory: terraform
        run: terraform fmt -check

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: terraform
        run: terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: terraform/tfplan

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Create terraform.tfvars from secrets
        working-directory: terraform
        run: |
          cat > terraform.tfvars <<EOF
          project_name        = "crypto-trading-bot"
          environment         = "prod"
          aws_region          = "${{ env.AWS_REGION }}"
          instance_type       = "t3.small"
          allowed_ips         = ${{ secrets.ALLOWED_IPS }}
          cognito_user_email  = "${{ secrets.COGNITO_USER_EMAIL }}"
          binance_api_key     = "${{ secrets.BINANCE_API_KEY }}"
          binance_api_secret  = "${{ secrets.BINANCE_API_SECRET }}"
          ssh_key_name        = "${{ secrets.SSH_KEY_NAME }}"
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Format
        working-directory: terraform
        run: terraform fmt

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: terraform/

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform-outputs
        working-directory: terraform
        run: |
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
          echo "instance_public_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
          echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
          echo "cognito_client_id=$(terraform output -raw cognito_client_id)" >> $GITHUB_OUTPUT

      - name: Update Cognito Callback URLs
        run: |
          ALB_DNS="${{ steps.terraform-outputs.outputs.alb_dns_name }}"
          USER_POOL_ID="${{ steps.terraform-outputs.outputs.cognito_user_pool_id }}"
          CLIENT_ID="${{ steps.terraform-outputs.outputs.cognito_client_id }}"

          aws cognito-idp update-user-pool-client \
            --user-pool-id "$USER_POOL_ID" \
            --client-id "$CLIENT_ID" \
            --region ${{ env.AWS_REGION }} \
            --callback-urls "http://localhost:3001" "https://${ALB_DNS}" \
            --logout-urls "http://localhost:3001" "https://${ALB_DNS}" \
            --allowed-o-auth-flows "code" "implicit" \
            --allowed-o-auth-scopes "email" "openid" "profile" \
            --allowed-o-auth-flows-user-pool-client \
            --supported-identity-providers "COGNITO"

  deploy-application:
    name: Deploy Application to EC2
    runs-on: ubuntu-latest
    needs: terraform-apply

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=crypto-trading-bot-prod-instance" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

      - name: Wait for instance to be ready
        run: |
          echo "Waiting for instance ${{ steps.get-instance.outputs.instance_id }} to be ready..."
          aws ec2 wait instance-status-ok --instance-ids ${{ steps.get-instance.outputs.instance_id }}
          echo "Instance is ready!"

      - name: Deploy application code via SSM
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /opt/trading-bot",
              "git pull origin main || true",
              "docker-compose build",
              "sudo systemctl restart trading-bot",
              "sleep 10",
              "sudo systemctl status trading-bot"
            ]' \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          # Wait for command to complete
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"

          # Get command output
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"

      - name: Health check via ALB
        run: |
          # Wait for application to be ready
          sleep 30

          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, 'crypto-trading-bot')].DNSName" \
            --output text)

          # Check health endpoint via ALB
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "http://$ALB_DNS/api/health" || echo "000")

          if [ "$RESPONSE" = "200" ]; then
            echo "‚úÖ Application deployed successfully!"
            echo "Dashboard URL: http://$ALB_DNS"
          else
            echo "‚ö†Ô∏è Health check returned status $RESPONSE"
            echo "Application may still be starting up..."
            echo "Dashboard URL: http://$ALB_DNS"
          fi

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: always()

    steps:
      - name: Deployment Success
        if: needs.deploy-application.result == 'success'
        run: |
          echo "üöÄ Deployment completed successfully!"
          echo "Dashboard: https://${{ needs.terraform-apply.outputs.alb_dns_name }}"

      - name: Deployment Failure
        if: needs.deploy-application.result != 'success'
        run: |
          echo "‚ùå Deployment failed!"
          exit 1

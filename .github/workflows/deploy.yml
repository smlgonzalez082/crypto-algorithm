name: Deploy to AWS

on:
  push:
    branches:
      - main  # Deploy only from main branch
  workflow_dispatch:  # Allow manual trigger

concurrency:
  group: deploy-production
  cancel-in-progress: true  # Automatically cancel previous runs

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: crypto-trading-bot-prod
  TERRAFORM_VERSION: 1.6.0

jobs:
  test:
    name: Run Tests Before Deploy
    uses: ./.github/workflows/test.yml

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    env:
      AWS_REGION: us-east-1
      AWS_DEFAULT_REGION: us-east-1
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set AWS credentials as env vars
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_REGION=us-east-1" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=us-east-1" >> $GITHUB_ENV

      - name: Check and fix AWS config
        run: |
          echo "=== AWS Config Before ==="
          cat ~/.aws/config || echo "No config file"
          echo "========================"

          # Remove any config that might have wrong region
          rm -rf ~/.aws/config
          mkdir -p ~/.aws

          # Create fresh config with us-east-1 only
          cat > ~/.aws/config <<EOF
          [default]
          region = us-east-1
          output = json
          EOF

          echo "=== AWS Config After ==="
          cat ~/.aws/config
          echo "========================"

      - name: Login to Amazon ECR (manual)
        id: login-ecr
        run: |
          # Get account ID and construct registry URL
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"

          echo "Logging into ECR registry: $REGISTRY"

          # Get ECR login password and login to Docker
          aws ecr get-login-password --region us-east-1 | \
            docker login --username AWS --password-stdin $REGISTRY

          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "Successfully logged into ECR in us-east-1"

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-scanning-configuration scanOnPush=true \
            --region ${{ env.AWS_REGION }} \
            --tags Key=Project,Value=crypto-trading-bot Key=Environment,Value=prod

      - name: Get AWS Account ID and construct tags
        id: aws-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"
          REPO="${REGISTRY}/crypto-trading-bot-prod"
          TAG1="${REPO}:${GITHUB_SHA}"
          TAG2="${REPO}:latest"

          echo "=== Docker Registry Configuration ==="
          echo "Account ID: ${ACCOUNT_ID}"
          echo "Registry: ${REGISTRY}"
          echo "Repository: ${REPO}"
          echo "Tag 1: ${TAG1}"
          echo "Tag 2: ${TAG2}"
          echo "======================================"

          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repo=${REPO}" >> $GITHUB_OUTPUT
          echo "tag1=${TAG1}" >> $GITHUB_OUTPUT
          echo "tag2=${TAG2}" >> $GITHUB_OUTPUT

      - name: Login to ECR (us-east-1 only)
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"

          echo "Logging into ECR registry: $REGISTRY"
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $REGISTRY

      - name: Build Docker image locally (no tags yet)
        env:
          DOCKER_BUILDKIT: 0
        run: |
          echo "Building Docker image WITHOUT tags to avoid auto-push"
          docker build --build-arg NODE_ENV=production -t temp-build .

      - name: Tag and push to ECR using AWS CLI
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com"
          REPO="crypto-trading-bot-prod"

          echo "Tagging image..."
          docker tag temp-build "${REGISTRY}/${REPO}:${GITHUB_SHA}"
          docker tag temp-build "${REGISTRY}/${REPO}:latest"

          echo "Images after tagging:"
          docker images | grep -E "(temp-build|crypto-trading-bot)"

          echo "Pushing to ${REGISTRY}/${REPO}:${GITHUB_SHA}"
          docker push "${REGISTRY}/${REPO}:${GITHUB_SHA}"

          echo "Pushing to ${REGISTRY}/${REPO}:latest"
          docker push "${REGISTRY}/${REPO}:latest"

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Create terraform.tfvars from secrets
        working-directory: terraform
        run: |
          cat > terraform.tfvars <<EOF
          project_name        = "crypto-trading-bot"
          environment         = "prod"
          aws_region          = "${{ env.AWS_REGION }}"
          instance_type       = "t3.small"
          allowed_ips         = ${{ secrets.ALLOWED_IPS }}
          cognito_user_email  = "${{ secrets.COGNITO_USER_EMAIL }}"
          binance_api_key     = "${{ secrets.BINANCE_API_KEY }}"
          binance_api_secret  = "${{ secrets.BINANCE_API_SECRET }}"
          ssh_key_name        = "${{ secrets.SSH_KEY_NAME }}"
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Format Check
        working-directory: terraform
        run: terraform fmt -check

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: terraform
        run: terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: terraform/tfplan

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    environment: production  # Requires manual approval

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Create terraform.tfvars from secrets
        working-directory: terraform
        run: |
          cat > terraform.tfvars <<EOF
          project_name        = "crypto-trading-bot"
          environment         = "prod"
          aws_region          = "${{ env.AWS_REGION }}"
          instance_type       = "t3.small"
          allowed_ips         = ${{ secrets.ALLOWED_IPS }}
          cognito_user_email  = "${{ secrets.COGNITO_USER_EMAIL }}"
          binance_api_key     = "${{ secrets.BINANCE_API_KEY }}"
          binance_api_secret  = "${{ secrets.BINANCE_API_SECRET }}"
          ssh_key_name        = "${{ secrets.SSH_KEY_NAME }}"
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: terraform/

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform-outputs
        working-directory: terraform
        run: |
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
          echo "instance_public_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
          echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT

  deploy-application:
    name: Deploy Application to EC2
    runs-on: ubuntu-latest
    needs: terraform-apply

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 instance IP
        id: get-instance
        run: |
          INSTANCE_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=crypto-trading-bot-prod-instance" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > /tmp/deploy_key.pem
          chmod 600 /tmp/deploy_key.pem

      - name: Deploy application code
        run: |
          ssh -i /tmp/deploy_key.pem -o StrictHostKeyChecking=no ec2-user@${{ steps.get-instance.outputs.instance_ip }} << 'ENDSSH'
            cd /opt/trading-bot

            # Pull latest code (or clone if first deploy)
            if [ -d ".git" ]; then
              git pull origin main
            else
              git clone https://github.com/${{ github.repository }}.git .
            fi

            # Build and restart application
            docker-compose build
            sudo systemctl restart trading-bot

            # Wait for service to start
            sleep 10

            # Check if service is running
            sudo systemctl status trading-bot
          ENDSSH

      - name: Health check
        run: |
          # Wait for application to be ready
          sleep 30

          # Check health endpoint
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            http://${{ steps.get-instance.outputs.instance_ip }}:3001/api/health)

          if [ "$RESPONSE" = "200" ]; then
            echo "âœ… Application deployed successfully!"
          else
            echo "âŒ Health check failed with status $RESPONSE"
            exit 1
          fi

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: always()

    steps:
      - name: Deployment Success
        if: needs.deploy-application.result == 'success'
        run: |
          echo "ðŸš€ Deployment completed successfully!"
          echo "Dashboard: https://${{ needs.terraform-apply.outputs.alb_dns_name }}"

      - name: Deployment Failure
        if: needs.deploy-application.result != 'success'
        run: |
          echo "âŒ Deployment failed!"
          exit 1
